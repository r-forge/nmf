
checkPlot.hook <- function (expr, msg='', width=1000, height=NULL) 
{
  ##@bdescr
  ## Saves a plot in a PNG file that will be included in the report.
  ## TODO: only works with HTML report, must be added it to the Text report
  ##
  ##@edescr
  ##@in  expr   : expression that generate th eplot
  ##@in  width  : plot width
  ##@in  height : plot height TODO: not used  
  ##@in  msg 	: plot msg explaining the plot . It will be used as the caption
  ##
  ##@ret        : [logical] TRUE
  ##
  ##@codestatus : testing
  
    if (missing(expr)) {
        stop("'expr' is missing.")
    }
    if (exists(".testLogger", envir = .GlobalEnv)) {
        .testLogger$incrementCheckNum()
    }
	
	# build the plot's filename is the testFunctionName.#.png where # is the current check number
	plotfile <- paste(.testLogger$getCurrentTestFunction(), .testLogger$getCheckNum(), 'png', sep='.')
	# reset the msg if none was provided
	if( msg == '' ) msg <- plotfile
	
	#plot in the PNG file
	png(file=plotfile, width=width)
	# evaluate the expression that generates the plot
	res <- try( eval(expr, envir = parent.frame()) )
	# close the graphic device
	dev.off()
		
	# test if everything went alright
	fileinfo <- file.info(plotfile)	
	if( inherits(res, "try-error") || is.na(fileinfo$size[1]) || fileinfo$size[1] == 0 ){
		#make sure the plot file is removed
		unlink(plotfile)
		
		if(exists(".testLogger", envir=.GlobalEnv)) {
      		.testLogger$setFailure()
    	}
		stop("Problem when generating plot:", res, msg)
	}
	
	if (exists(".testLogger", envir = .GlobalEnv)) {
		.testLogger$setPlot(plotfile, msg)
   	}
   	return(TRUE)
}


##  RUnit : A unit test framework for the R programming language
##  Copyright (C) 2003-2007  Thomas Koenig, Matthias Burger, Klaus Juenemann
##
##  This program is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 2 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program; if not, write to the Free Software
##  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

##  $Id: testLogger.r,v 1.14 2008/06/18 17:13:49 burgerm Exp $


.newTestLogger.hook <- function(useOwnErrorHandler) {
  ##@bdescr
  ## creates a new, empty TestLogger 'object'.
  ## TestLogger is an object based on the 'closure trick'. It has the task
  ## to store, administrate and print the test protocol.
  ##@edescr
  ##@in  useOwnErrorHandler  : [logical] 
  ##@ret                     : [list]
  ##
  ##@codestatus : internal

  ## private data:
  ## -----------------------
  .testData <- list()
  class(.testData) <- "RUnitTestData"
  .currentTestSuiteName <- NULL
  .currentSourceFileName <- NULL
  .currentTestFunctionName <- NULL

  ## book keeping variables for individual test functions
  ## can be reset by cleanup function
  .currentTraceBack <- NULL
  .failure <- FALSE
  .deactivationMsg <- NULL   ## if non-NULL test function is deactivated
  .checkNum <- 0
  .plots <- NULL # will contain the list of the plots generated by the function

  ## define own error handler
  ## -----------------------
  errorHandler <- function() {
    ##@bdescr
    ##  used as default error handler during test case execution iff
    ##  the user specified 'useOwnErrorHandler' as TRUE (default).
    ##  called in case an error condition, typically stop() has been signalled.
    ##  tries to create a traceback object, currently only used by addError().
    ##
    ##  not provided via testLogger but used by R's error handler.
    ##@edescr
    ##
    ##@ret  : [NULL] used for it's side effect
    ##
    ##@codestatus : internal
    
    res <- try(dump.frames())
    if (inherits(res, "try-error")) {
      .currentTraceBack <<- "traceback not available (dump.frames failed)."
    } else {
      .currentTraceBack <<- names(last.dump)[-length(last.dump)]
    }
  }
  
  if(useOwnErrorHandler) {
    options(error=errorHandler)
  }



  ## public methods:
  ## -----------------------
  getTestData <- function() {
    ##@bdescr
    ## returns the protocol data collected during the test runs
    ##@edescr
    return(.testData)
  }

  setCurrentTestSuite <- function(testSuite) {
    ##@bdescr
    ## specify the test suite that is currently executed.
    ##@edescr
    ##@in testSuite : [testSuite - list] the current testSuite

    if(is.null(testSuite)) {
      .currentTestSuiteName <<- NULL
    }
    else {
      if(is.element(testSuite$name, names(.testData))) {
        stop(paste("Duplicate test suite:", testSuite$name))
      }
      .currentTestSuiteName <<- testSuite$name
      .testData[[testSuite$name]] <<- list(nTestFunc=0,
                                          nDeactivated=0,
                                          nErr=0,
                                          nFail=0,
                                          dirs=testSuite$dirs,
                                          testFileRegexp=testSuite$testFileRegexp,
                                          testFuncRegexp=testSuite$testFuncRegexp,
                                          sourceFileResults=list())
    }
  }

  setCurrentSourceFile <- function(sourceFileName) {
    ##@bdescr
    ## specify the source file whose test functions are currently executed
    ##@edescr
    ##@in sourceFileName : [character] name of current source file

    if(is.null(sourceFileName)) {
      .currentSourceFileName <<- NULL
    }
    else {
      .currentSourceFileName <<- sourceFileName
      .testData[[.currentTestSuiteName]]$sourceFileResults[[sourceFileName]] <<- list()
    }
  }
  
   setCurrentTestFunction <- function(functionName) {
    ##@bdescr
    ## specify the source file whose test functions are currently executed
    ##@edescr
    ##@in sourceFileName : [character] name of current source file

    if(is.null(functionName)) {
      .currentTestFunctionName <<- NULL
    }
    else {
      .currentTestFunctionName <<- functionName	  
    }
  }
  
    getCurrentTestFunction <- function() {
		##@bdescr
		##  return current test function name being evaluated
		##@edescr
		return(.currentTestFunctionName)
	  }


  addSuccess <- function(testFuncName, secs) {
    ##@bdescr
    ## add a successful test function run.
    ##@edescr
    ##@in testFuncName : [character] name of test function
    ##@in secs : [numeric] time in seconds needed by the test function to complete

    .testData[[.currentTestSuiteName]]$nTestFunc <<- 1 + .testData[[.currentTestSuiteName]]$nTestFunc

    .testData[[.currentTestSuiteName]]$sourceFileResults[[.currentSourceFileName]][[testFuncName]] <<-
      list(kind="success", checkNum=.checkNum, time=secs, plots=.plots)
  }

  addError <- function(testFuncName, errorMsg) {
    ##@bdescr
    ## add a test function that generated an error.
    ##@edescr
    ##@in testFuncName : [character] name of test function
    ##@in errorMsg : [character] the error message

    .testData[[.currentTestSuiteName]]$nTestFunc <<- 1 + .testData[[.currentTestSuiteName]]$nTestFunc
    .testData[[.currentTestSuiteName]]$nErr <<- 1 + .testData[[.currentTestSuiteName]]$nErr

    .testData[[.currentTestSuiteName]]$sourceFileResults[[.currentSourceFileName]][[testFuncName]] <<-
      list(kind="error", msg=errorMsg, checkNum=.checkNum, traceBack=.currentTraceBack, plots=.plots)
  }

  addFailure <- function(testFuncName, failureMsg) {
    ##@bdescr
    ## add a test function that generated an error.
    ##@edescr
    ##@in testFuncName : [character] name of test function
    ##@in failureMsg : [character] the failure message

    .testData[[.currentTestSuiteName]]$nTestFunc <<- 1 + .testData[[.currentTestSuiteName]]$nTestFunc
    .testData[[.currentTestSuiteName]]$nFail <<- 1 + .testData[[.currentTestSuiteName]]$nFail

    .testData[[.currentTestSuiteName]]$sourceFileResults[[.currentSourceFileName]][[testFuncName]] <<-
      list(kind="failure", msg=failureMsg, checkNum=.checkNum, traceBack=NULL, plots=.plots)  ## traceBack is useless in this case
  }

  addDeactivated <- function(testFuncName) {
    ##@bdescr
    ## add a deactivated test function that generated an error.
    ##@edescr
    ##@in testFuncName : [character] name of test function


    .testData[[.currentTestSuiteName]]$nDeactivated <<- 1 + .testData[[.currentTestSuiteName]]$nDeactivated
    .testData[[.currentTestSuiteName]]$sourceFileResults[[.currentSourceFileName]][[testFuncName]] <<-
      list(kind="deactivated", msg=.deactivationMsg, checkNum=.checkNum, plots=.plots)
  }

  addCheckNum <- function(testFuncName) {
    ##@bdescr
    ## add total number of checks performed 
    ##@edescr
    ##@in testFuncName : [character] name of test function


    .testData[[.currentTestSuiteName]]$sourceFileResults[[.currentSourceFileName]][[testFuncName]]$checkNum <<- .checkNum
      
  }
  
  cleanup <- function() {
    ##@bdescr
    ## reset book keeping variables like .failure, ...
    ## should be called before each test function execution
    ##@edescr

    .currentTraceBack <<- NULL
    .failure <<- FALSE
    .deactivationMsg <<- NULL
    .checkNum <<- 0
	.plots <<- NULL # reset the plot list
  }

  isFailure <- function() {
    ##@bdescr
    ##
    ##@edescr
    return(.failure)
  }

  setFailure <- function() {
    ##@bdescr
    ##  set failure status to TRUE
    ##@edescr
    .failure <<- TRUE
  }

  isDeactivated <- function() {
    ##@bdescr
    ##
    ##@edescr
    ##@ret  : [logical] TRUE if deactivation msg is not NULL
    return(!is.null(.deactivationMsg))
  }

  setDeactivated <- function(msg) {
    ##@bdescr
    ##  set deactivation msg variable, indicating a deactivated test case
    ##@edescr
    ##@in  msg : [character] message string
    
    if (length(msg) > 1) {
      msg <- paste(msg, collapse=" ")
    }
    .deactivationMsg <<- msg
  }

  incrementCheckNum <- function() {
    ##@bdescr
    ##  increment internal counter of total num of test cases
    ##@edescr
    .checkNum <<- 1 + .checkNum
  }
  
  getCheckNum <- function() {
    ##@bdescr
    ##  return counter value for total num of test cases
    ##@edescr
    return(.checkNum)
  }
  
  setPlot <- function(name, msg=''){
   	##@bdescr
    ## add a plot to a test function.
    ##@edescr
    ##@in testFuncName : [character] name of test function
    ##@in name : [character] filename
	##@in msg : [character] message string
	##@edescr	
	
	if( is.null(.plots) ) .plots <<- list()
	.plots[[name]] <<- msg
		
  }
    
  return(list(getTestData=getTestData,
              setCurrentTestSuite=setCurrentTestSuite,
              setCurrentSourceFile=setCurrentSourceFile,
			  setCurrentTestFunction=setCurrentTestFunction,
			  getCurrentTestFunction=getCurrentTestFunction,			  
              addSuccess=function(testFuncName, secs) addSuccess(testFuncName, secs),
              addError=function(testFuncName, errorMsg) addError(testFuncName, errorMsg),
              addFailure=function(testFuncName, failureMsg) addFailure(testFuncName, failureMsg),
              addDeactivated=function(testFuncName) addDeactivated(testFuncName),
              addCheckNum=function(testFuncName) addCheckNum(testFuncName),
              isFailure=isFailure,
              setFailure=setFailure,
              isDeactivated=isDeactivated,
              setDeactivated=function(msg) setDeactivated(msg),
              incrementCheckNum=incrementCheckNum,
              getCheckNum=getCheckNum,
              cleanup=cleanup,
			  setPlot=function(name, ...) setPlot(name, ...)))
}


.executeTestCase.hook <- function(funcName, envir, setUpFunc, tearDownFunc)
{
  ##@bdescr
  ##  Internal Function.
  ##  Execute individual test case, record logs and change state of global TestLogger object.
  ##@edescr
  ##
  ##@in  funcName     : [character] name of test case function
  ##@in  envir        : [environment]
  ##@in  setUpFunc    : [function]
  ##@in  tearDownFunc : [function]
  ##@ret              : [NULL]
  ##
  ##@codestatus : internal
  
  ## set the current function to be executed
  .testLogger$setCurrentTestFunction(funcName)
  
  ##  write to stdout for logging

  func <- get(funcName, envir=envir)
  ## anything else than a function is ignored.
  if(mode(func) != "function") {
    return()
  }

  cat("\n\nExecuting test function",funcName," ... ")

  ## safe execution of setup function
  res <- try(setUpFunc())
  if (inherits(res, "try-error")) {
    message <- paste("Error executing .setUp before",funcName, ":", geterrmessage())
    .testLogger$addError(testFuncName=paste(".setUp (before ", funcName, ")", sep=""),
                         errorMsg=message)
    return()
  }

  ## reset book keeping variables in .testLogger
  .testLogger$cleanup()
  
  ## ordinary test function execution:
  timing <- try(system.time(func()))
  if (inherits(timing, "try-error")) {
    if(.testLogger$isFailure()) {
      .testLogger$addFailure(testFuncName=funcName,
                             failureMsg=geterrmessage())
    }
    else if(.testLogger$isDeactivated()) {
      .testLogger$addDeactivated(testFuncName=funcName)
    }
    else {
      .testLogger$addError(testFuncName=funcName,
                           errorMsg=geterrmessage())
    }
  }
  else {
    .testLogger$addSuccess(testFuncName=funcName, secs=round(timing[3], 2))
  }

  ##  add number of check function calls within test case
  .testLogger$addCheckNum(testFuncName=funcName)
  
  ## safe execution of tearDown function
  res <- try(tearDownFunc())
  if (inherits(res, "try-error")) {
    message <- paste("Error executing .tearDown after",funcName, ":", geterrmessage())
    .testLogger$addError(testFuncName=paste(".tearDown (after ", funcName, ")", sep=""),
                         errorMsg=message)
    return()
  }

  cat(" done successfully.\n\n")
  return()
}



##  RUnit : A unit test framework for the R programming language
##  Copyright (C) 2003-2008  Thomas Koenig, Matthias Burger, Klaus Juenemann
##
##  This program is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 2 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program; if not, write to the Free Software
##  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

##  $Id: htmlProtocol.r,v 1.26 2008/11/07 13:49:58 burgerm Exp $

printHTMLProtocol.hook <- function(testData,
                              fileName = "",
                              separateFailureList = TRUE,
                              traceBackCutOff=9,
                              testFileToLinkMap=function(x) x) {

  ##@bdescr
  ##  Report generator
  ##  Extracts the log information stored in the 'RUnitTestData' test run object
  ##  and generates a well formated HTML output.
  ##@edescr
  ##
  ##@in  testData            : [RUnitTestData] S3 class object
  ##@in  fileName            : [character]
  ##@in  separateFailureList : [logical] if TRUE (default) add a list of all failures
  ##@in  traceBackCutOff     : [integer] number of steps back in the trace back stack to be displayed
  ##@in  testFileToLinkMap   : [function] a function transforming the full name of the test file to a link location
  ##@ret                     : [logical] TRUE if execution completed wo error
  ##
  ##@codestatus : testing
    
  ## --------------------------------
  ##  CHECK OF INPUT DATA
  ## --------------------------------
  if (!is(testData, "RUnitTestData"))
  {
    stop("Argument 'testData' must be of class 'RUnitTestData'.")
  }

  if (!is.character(fileName))
  {
    stop("Argument 'fileName' has to be of type character.")
  }
  if (length(fileName) != 1)
  {
    stop("Argument 'fileName' must contain exactly one element.")
  }

  if (!is.logical(separateFailureList))
  {
    stop("Argument 'separateFailureList' has to be of type logical.")
  }
  if (length(separateFailureList) != 1)
  {
    stop("Argument 'separateFailureList' must contain exactly one element.")
  }

  if (!is.numeric(traceBackCutOff))
  {
    stop("Argument 'traceBackCutOff' has to be of type logical.")
  }
  if (length(traceBackCutOff) != 1)
  {
    stop("Argument 'traceBackCutOff' must contain exactly one element.")
  }
  if (traceBackCutOff < 0 || traceBackCutOff > 100)
  {
    stop("Argument 'traceBackCutOff' out of valid range [0, 100].")
  }

  ## --------------------------------
  ## HELPER FUNCTIONS
  ## --------------------------------

  ## get singular or plural right
  sop <- function(number, word, plext="s")
  {
    ifelse(number == 1, paste(number, word),
           paste(number, paste(word, plext, sep="")))
  }

  pr <- function(...) {
    RUnit:::writeRaw(paste(...), htmlFile=fileName)
    RUnit:::writeRaw("<br/>", htmlFile=fileName)
  }


  writeP <- function(string, para="") {
    RUnit:::writeBeginTag("p", para=para, htmlFile=fileName)
    RUnit:::writeRaw(string, htmlFile=fileName)
    RUnit:::writeEndTag("p", htmlFile=fileName)
    RUnit:::writeCR(htmlFile=fileName)
  }
  
  writeLi <- function(..., para="") {
    RUnit:::writeBeginTag("li", para=para, htmlFile=fileName)
    RUnit:::writeRaw(paste(...), htmlFile=fileName)
    RUnit:::writeEndTag("li", htmlFile=fileName)
  }
  
  createTestFuncRef <- function(testSuite, srcFileName, testFuncName,
                                asAnchor=FALSE) {
    tmp <- paste(testSuite, srcFileName, testFuncName, sep="_")
    if(asAnchor) {
      return(paste("#", gsub("/", "_", tmp), sep=""))
    }
    else {
      return(gsub("/", "_", tmp))
    }
  }

  printTraceBack <- function(traceBack) {
    if(length(traceBack) > 0) {
      RUnit:::writeRaw("Call Stack:<br/>", htmlFile=fileName)

      if(traceBackCutOff > length(testFuncInfo$traceBack)) {
        RUnit:::writeRaw("(traceBackCutOff argument larger than length of trace back: full trace back printed)<br/>", htmlFile=fileName)
        RUnit:::writeBeginTag("ol", htmlFile=fileName)
        for(i in seq_along(traceBack)) {
          RUnit:::writeBeginTag("li", htmlFile=fileName)
          RUnit:::writeRaw(traceBack[i], htmlFile=fileName)
          RUnit:::writeEndTag("li", htmlFile=fileName)
        }
      }
      else {
        RUnit:::writeBeginTag("ol", htmlFile=fileName)
        for(i in traceBackCutOff:length(traceBack)) {
          RUnit:::writeBeginTag("li", htmlFile=fileName)
          RUnit:::writeRaw(traceBack[i], htmlFile=fileName)
          RUnit:::writeEndTag("li", htmlFile=fileName)
        }
      }
      RUnit:::writeEndTag("ol", htmlFile=fileName)
    }
  }

	formatPRE <- function(string, para="") {
    	paste("<pre ", para=para, ">", string, "</pre>", collapse="")   
  	}
  
	writeJavascript <- function(script, htmlFile){
		RUnit:::writeBeginTag("script", para=c('type="text/javascript"'), htmlFile=fileName)
		RUnit:::writeRaw(script, htmlFile=fileName)
		RUnit:::writeEndTag("script", htmlFile=fileName)
	}
	
  errorStyle <- "color:red"
  deactivatedStyle <- "background-color:yellow"


  ## --------------------------------------------
  ## PART 1: TITLE AND BASIC ERROR INFORMATION
  ## --------------------------------------------

  ## title
  title <- paste("RUNIT TEST PROTOCOL", date(), sep="--")
  RUnit:::writeHtmlHeader(title, htmlFile=fileName)
  
  ## define a javascript function to toggle the display of HTML elements and to load images in an element
  writeJavascript("function toggleElement(id){ 
  	elem = document.getElementById(id); 
  	if(elem.style.display=='none') elem.style.display='block'; 
  	else elem.style.display='none';
  	return false;
  }
  
  function loadImage(id, image){
  	elem = document.getElementById(id); 
	elem.src = image;	
	return false;
  }", htmlFile=fileName)
  
  RUnit:::writeHtmlSection(title, 1, htmlFile=fileName)

  if(length(testData) == 0) {
    writeP(" no test cases :-(")
    return(invisible(TRUE))
  }
  ## basic Info
  errInfo <- getErrors(testData)
  writeP(paste("Number of test functions:", errInfo$nTestFunc))
  if(errInfo$nDeactivated > 0) {
    writeP(paste("Number of deactivated test functions:", errInfo$nDeactivated),
           para=ifelse(errInfo$nDeactivated == 0, "", paste("style", deactivatedStyle, sep="=")))
  }
  writeP(paste("Number of errors:", errInfo$nErr),
         para=ifelse(errInfo$nErr == 0, "", paste("style", errorStyle, sep="=")))
  writeP(paste("Number of failures:", errInfo$nFail),
         para=ifelse(errInfo$nFail == 0, "", paste("style", errorStyle, sep="=")))
  RUnit:::writeHtmlSep(htmlFile=fileName)

  ## --------------------------------
  ## PART 2: TABLE OF TEST SUITES
  ## --------------------------------

  ## summary of test suites
  RUnit:::writeHtmlSection(sop(length(testData), "Test suite"), 3, htmlFile=fileName)
  ## table of test suites
  if(errInfo$nDeactivated > 0) {
    RUnit:::writeBeginTable(c("Name", "Test functions", "Deactivated", "Errors", "Failures"),
                    width="80%",
                    htmlFile=fileName,
                    columnWidth=c("20%", "20%", "20%", "20%", "20%"))
    for(tsName in names(testData)) {
      rowString <- c(paste("<a href=\"#", tsName, "\">", tsName, "</a>", sep=""),
                     testData[[tsName]]$nTestFunc,
                     testData[[tsName]]$nDeactivated,
                     testData[[tsName]]$nErr,
                     testData[[tsName]]$nFail)
      rowCols <- c("", "",
                   ifelse(testData[[tsName]]$nDeactivated==0, "", "yellow"),
                   ifelse(testData[[tsName]]$nErr==0, "", "red"),
                   ifelse(testData[[tsName]]$nFail==0, "", "red"))

      RUnit:::writeTableRow(row=rowString, bgcolor=rowCols, htmlFile=fileName)
    }
    RUnit:::writeEndTable(htmlFile=fileName)
  }
  else {  ## skip 'deactivated' column if no functions have been deactivated
    RUnit:::writeBeginTable(c("Name", "Test functions", "Errors", "Failures"),
                    width="60%",
                    htmlFile=fileName,
                    columnWidth=c("30%", "30%", "20%", "20%"))
    for(tsName in names(testData)) {
      rowString <- c(paste("<a href=\"#", tsName, "\">", tsName, "</a>", sep=""),
                     testData[[tsName]]$nTestFunc,
                     testData[[tsName]]$nErr,
                     testData[[tsName]]$nFail)
      rowCols <- c("", "",
                   ifelse(testData[[tsName]]$nErr==0, "", "red"),
                   ifelse(testData[[tsName]]$nFail==0, "", "red"))

      RUnit:::writeTableRow(row=rowString, bgcolor=rowCols, htmlFile=fileName)
    }
    RUnit:::writeEndTable(htmlFile=fileName)
  }
  RUnit:::writeHtmlSep(htmlFile=fileName)

  ## ------------------------------------------------
  ## PART 3: ERROR, FAILURE AND DEACTIVATED TABLES
  ## -------------------------------------------------

  ## error table
  if(separateFailureList && (errInfo$nErr > 0)) {
   RUnit:::writeHtmlSection("Errors", 3, htmlFile=fileName)
   RUnit:::writeBeginTable(c("Test suite : test function", "message"),
                    htmlFile=fileName,
                    columnWidth=c("30%", "70%"))
    for(tsName in names(testData)) {
      if(testData[[tsName]]$nErr > 0) {
        srcFileRes <- testData[[tsName]]$sourceFileResults
        srcFileNames <- names(srcFileRes)
        for(i in seq_along(srcFileRes)) {
          testFuncNames <- names(srcFileRes[[i]])
          for(j in seq_along(testFuncNames)) {
            funcList <- srcFileRes[[i]][[testFuncNames[j]]]
            if(funcList$kind == "error") {
              lnk <- paste("<a href=\"",
                           createTestFuncRef(tsName, srcFileNames[i],
                                             testFuncNames[j], asAnchor=TRUE),
                           "\">",
                           paste(tsName, testFuncNames[j], sep=" : "),
                           "</a>", sep="")
             RUnit:::writeTableRow(row=c(lnk, formatPRE(funcList$msg)),
                            htmlFile=fileName)
            }
          }
        }
      }
    }
   RUnit:::writeEndTable(htmlFile=fileName)
   RUnit:::writeHtmlSep(htmlFile=fileName)
  }

  ## failure table
  if(separateFailureList && (errInfo$nFail > 0)) {
   RUnit:::writeHtmlSection("Failures", 3, htmlFile=fileName)
   RUnit:::writeBeginTable(c("Test suite : test function", "message"),
                    htmlFile=fileName,
                    columnWidth=c("30%", "70%"))
    for(tsName in names(testData)) {
      if(testData[[tsName]]$nFail > 0) {
        srcFileRes <- testData[[tsName]]$sourceFileResults
        srcFileNames <- names(srcFileRes)
        for(i in seq_along(srcFileRes)) {
          testFuncNames <- names(srcFileRes[[i]])
          for(j in seq_along(testFuncNames)) {
            funcList <- srcFileRes[[i]][[testFuncNames[j]]]
            if(funcList$kind == "failure") {
              lnk <- paste("<a href=\"",
                           createTestFuncRef(tsName, srcFileNames[i],
                                             testFuncNames[j], asAnchor=TRUE),
                           "\">",
                           paste(tsName, testFuncNames[j], sep=" : "),
                           "</a>", sep="")
             RUnit:::writeTableRow(row=c(lnk, formatPRE(funcList$msg)),
                            htmlFile=fileName)
            }
          }
        }
      }
    }
   RUnit:::writeEndTable(htmlFile=fileName)
   RUnit:::writeHtmlSep(htmlFile=fileName)
  }


  ## deactivated table
  if(separateFailureList && (errInfo$nDeactivated > 0)) {
   RUnit:::writeHtmlSection("Deactivated", 3, htmlFile=fileName)
   RUnit:::writeBeginTable(c("Test suite : test function", "message"),
                    htmlFile=fileName,
                    columnWidth=c("30%", "70%"))
    for(tsName in names(testData)) {
      if(testData[[tsName]]$nDeactivated > 0) {
        srcFileRes <- testData[[tsName]]$sourceFileResults
        srcFileNames <- names(srcFileRes)
        for(i in seq_along(srcFileNames)) {
          testFuncNames <- names(srcFileRes[[i]])
          for(j in seq_along(testFuncNames)) {
            funcList <- srcFileRes[[i]][[testFuncNames[j]]]
            if(funcList$kind == "deactivated") {
              lnk <- paste("<a href=\"",
                           createTestFuncRef(tsName, srcFileNames[i],
                                             testFuncNames[j], asAnchor=TRUE),
                           "\">",
                           paste(tsName, testFuncNames[j], sep=" : "),
                           "</a>", sep="")
             RUnit:::writeTableRow(row=c(lnk, formatPRE(funcList$msg)),
                            htmlFile=fileName)
            }
          }
        }
      }
    }
   RUnit:::writeEndTable(htmlFile=fileName)
   RUnit:::writeHtmlSep(htmlFile=fileName)
  }

  ## --------------------------------
  ## PART 4: DETAILS
  ## --------------------------------

 RUnit:::writeHtmlSection("Details", 3, htmlFile=fileName)

  ## loop over all test suites
  for(tsName in names(testData)) {
    tsList <- testData[[tsName]]
    RUnit:::writeBeginTag("p", htmlFile=fileName)

    RUnit:::writeBeginTag("a", para=paste("name=\"", tsName, "\"", sep=""),
                  htmlFile=fileName)
   RUnit:::writeHtmlSection(paste("Test Suite:", tsName), 5, htmlFile=fileName)
    RUnit:::writeEndTag("a", htmlFile=fileName)

    pr("Test function regexp:", tsList$testFuncRegexp)
    pr("Test file regexp:", tsList$testFileRegexp)
    if(length(tsList$dirs) == 0) {
      pr("No directories !")
    }
    else {
      if(length(tsList$dirs) == 1) {
        pr("Involved directory:")
      }
      else {
        pr("Involved directories:")
      }
      for(dir in tsList$dirs) {
        pr(dir)
      }
      res <- tsList$sourceFileResults
      testFileNames <- names(res)
      if(length(res) == 0) {
        pr(" no test files")
      }
      else {
        ## loop over all source files
        RUnit:::writeBeginTag("ul", htmlFile=fileName)
        for(testFileName in testFileNames) {
          testFuncNames <- names(res[[testFileName]])
          if(length(testFuncNames) > 0) {
            RUnit:::writeBeginTag("li", htmlFile=fileName)
           RUnit:::writeLink(target=testFileToLinkMap(testFileName),
                      name=paste("Test file:", basename(testFileName)),
                      htmlFile=fileName)
            ## loop over all test functions in the test file
            RUnit:::writeBeginTag("ul", htmlFile=fileName)
            for(testFuncName in testFuncNames) {
              RUnit:::writeBeginTag("li", htmlFile=fileName)
              testFuncInfo <- res[[testFileName]][[testFuncName]]
              anchorName <- createTestFuncRef(tsName, testFileName, testFuncName)
              RUnit:::writeBeginTag("a", para=paste("name=\"", anchorName, "\"", sep=""),
                            htmlFile=fileName)
              if(testFuncInfo$kind == "success") {
                pr(paste(testFuncName, ": (",testFuncInfo$checkNum, " checks) ... OK (", testFuncInfo$time,
                         " seconds)", sep=""))
                RUnit:::writeEndTag("a", htmlFile=fileName)
              }
              else {
                if(testFuncInfo$kind == "error") {
                  RUnit:::writeBeginTag("u", para=paste("style", errorStyle, sep="="),
                                htmlFile=fileName)
                  RUnit:::writeRaw(paste(testFuncName, ": ERROR !!  ", sep=""),
                           htmlFile=fileName)
                  RUnit:::writeEndTag("u", htmlFile=fileName)
                  RUnit:::writeEndTag("a", htmlFile=fileName)
                }
                else if (testFuncInfo$kind == "failure") {
                  RUnit:::writeBeginTag("u", para=paste("style", errorStyle, sep="="),
                                htmlFile=fileName)
                  RUnit:::writeRaw(paste(testFuncName, ": FAILURE !! (check number ",
                                 testFuncInfo$checkNum, ")  ", sep=""),
                           htmlFile=fileName)
                  RUnit:::writeEndTag("u", htmlFile=fileName)
                  RUnit:::writeEndTag("a", htmlFile=fileName)
                }
                else if (testFuncInfo$kind == "deactivated") {				                  
                  RUnit:::writeRaw(paste(testFuncName, ": ("
				  			,testFuncInfo$checkNum, " checks) ... OK (", testFuncInfo$time, " seconds) ", sep=""),
                           htmlFile=fileName)
                  RUnit:::writeBeginTag("u", para=paste("style", deactivatedStyle, sep="="),
                                htmlFile=fileName)
                  RUnit:::writeRaw(" DEACTIVATED, ", htmlFile=fileName)
					RUnit:::writeEndTag("u", htmlFile=fileName)
                  RUnit:::writeEndTag("a", htmlFile=fileName)
                }
                else {
                  writeLi(paste(testFuncName, ": unknown error kind", sep=""))
                  RUnit:::writeEndTag("a", htmlFile=fileName)
                }
                pr(testFuncInfo$msg)
                printTraceBack(testFuncInfo$traceBack)
              }
			  
			  # BEGIN_PLOT: Add plotting functionnality			  			  
			  if( !is.null(testFuncInfo$plots) &&  length(testFuncInfo$plots) ){
			  	
				plot.id <- paste('plots_', testFuncName, sep='')				
				RUnit:::writeRaw('<table><tr><td valign="top">', htmlFile=fileName)
				RUnit:::writeRaw(paste("<a href=\"\" onclick=\"return toggleElement('", plot.id,"');\">Plots &nabla;</a>", sep=''), htmlFile=fileName)
				RUnit:::writeRaw(paste('</td><td id="', plot.id,'" style="display:none">', sep=''), htmlFile=fileName)
				#RUnit:::writeBeginTag('div', para=paste('id="', plot.id,'"', sep=''), htmlFile=fileName)
				imgs.html <- ''
				imgs.links <- ''
			  	lapply(names(testFuncInfo$plots), function(x){
					img.id <- paste('img_', x, sep='')
					
					caption <- testFuncInfo$plots[[x]]					
					imgs.links <<- paste(imgs.links
										, "<a href=\"\" onclick=\"document.getElementById('caption_", testFuncName,"').innerHTML=this.innerHTML;"
										," return loadImage('img_", testFuncName,"', '", x,"');\"> &bull;", caption, '</a> ', sep='')
					imgs.html <<- paste(imgs.html, 
						"<div id=\"", img.id, "\" style=\"display:none\">\n"
						, "<h4>", caption,"</h4>\n"
						, "<img src=\"", x, "\"/>\n"
						, "</div>"
						, sep='')
				})						
				RUnit:::writeRaw(imgs.links, htmlFile=fileName)
				RUnit:::writeRaw(paste('<h4 id="caption_', testFuncName,'"></h4><img id="img_', testFuncName,'"src="" />', sep=''), htmlFile=fileName)
				#RUnit:::writeEndTag('div', htmlFile=fileName)
				RUnit:::writeRaw('</td></tr></table>', htmlFile=fileName)				
			  }
			  
			  # END_PLOT
              RUnit:::writeEndTag("li", htmlFile=fileName)
            }
            RUnit:::writeEndTag("ul", htmlFile=fileName)
          }
          RUnit:::writeEndTag("li", htmlFile=fileName)
        }
        RUnit:::writeEndTag("ul", htmlFile=fileName)
      }
    }
   RUnit:::writeHtmlSep(htmlFile=fileName)
  }



  ver <- cbind(unlist(version))
  
  ##  add host name
  ver <- rbind(ver, Sys.info()["nodename"])
  rownames(ver)[dim(ver)[1]] <- "host"
  colnames(ver) <- "Value"

  ##  compiler used (under *nix)
  rhome <- Sys.getenv("R_HOME")
  
  ##  on Windows Makeconf does not exist
  ##  other than that we have no indication which compiler
  ##  would be used for R CMD INSTALL so we report NA
  gccVersion <- as.character(NA)
  makeconfFile <- file.path(rhome, "etc", "Makeconf")
  if (file.exists(makeconfFile) && identical(.Platform$OS.type, "unix")) {
    gccVersion <- system(paste("cat ", makeconfFile," | grep  \"^CXX =\" "),
                         intern=TRUE)
    gccVersion <- sub("^CXX[ ]* =[ ]*", "", gccVersion)
  }

  ver <- rbind(ver, gccVersion)
  rownames(ver)[dim(ver)[1]] <- "compiler"

  
 RUnit:::writeHtmlTable(ver,
                 htmlFile=fileName,
                 border=0,
                 width="80%",
                 append=TRUE)
  
  
  ## finish html document
 RUnit:::writeHtmlEnd(htmlFile=fileName)

  return(invisible(TRUE))
}
