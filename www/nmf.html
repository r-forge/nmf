<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>nmf. NMF 0.8.27</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="">

<link href="css/bootstrap.css" rel="stylesheet">
<link href="css/bootstrap-responsive.css" rel="stylesheet">
<link href="css/highlight.css" rel="stylesheet">
<link href="css/staticdocs.css" rel="stylesheet">

<!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
  </head>

  <body>
    <div class="navbar">
  <div class="navbar-inner">
    <div class = "container">
      <a class="brand" href="index.html">NMF 0.8.27</a>
      <div class="nav">
        <ul class="nav">
        <li><a href="_MAN.html"><i class="icon-home icon-white"></i> Index</a></li>
       </ul>
   	  </div>
    </div>
  </div>
</div>

    <div class="container">
      <header>
        
      </header>
      
      <h1>Running NMF algorithms</h1>

<div class="row">
  <div class="span8">
    <h2>Usage</h2>
    <pre><span class="functioncall"><a href='nmf.html'>nmf</a></span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="symbol">rank</span><span class="keyword">,</span> <span class="symbol">method</span><span class="keyword">,</span> <span class="symbol">...</span><span class="keyword">)</span>

<span class="comment"><span class="label label-important">S4</span> (matrix,numeric,NULL)</span>
<span class="functioncall">`nmf`</span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="symbol">rank</span><span class="keyword">,</span> <span class="symbol">method</span><span class="keyword">,</span> <span class="argument">seed</span> <span class="argument">=</span> NULL<span class="keyword">,</span> <span class="argument">model</span> <span class="argument">=</span> NULL<span class="keyword">,</span> <span class="symbol">...</span><span class="keyword">)</span>

<span class="comment"><span class="label label-important">S4</span> (matrix,numeric,function)</span>
<span class="functioncall">`nmf`</span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="symbol">rank</span><span class="keyword">,</span> <span class="symbol">method</span><span class="keyword">,</span> <span class="symbol">seed</span><span class="keyword">,</span> <span class="argument">model</span> <span class="argument">=</span> <span class="string">"NMFstd"</span><span class="keyword">,</span> <span class="symbol">...</span><span class="keyword">,</span> <span class="symbol">name</span><span class="keyword">,</span> <span class="argument">objective</span> <span class="argument">=</span> <span class="string">"euclidean"</span><span class="keyword">,</span>
  <span class="argument">mixed</span> <span class="argument">=</span> <span class="number">FALSE</span><span class="keyword">)</span>

<span class="comment"><span class="label label-important">S4</span> (matrix,NMF,ANY)</span>
<span class="functioncall">`nmf`</span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="symbol">rank</span><span class="keyword">,</span> <span class="symbol">method</span><span class="keyword">,</span> <span class="symbol">seed</span><span class="keyword">,</span> <span class="symbol">...</span><span class="keyword">)</span>

<span class="comment"><span class="label label-important">S4</span> (matrix,NULL,ANY)</span>
<span class="functioncall">`nmf`</span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="symbol">rank</span><span class="keyword">,</span> <span class="symbol">method</span><span class="keyword">,</span> <span class="symbol">seed</span><span class="keyword">,</span> <span class="symbol">...</span><span class="keyword">)</span>

<span class="comment"><span class="label label-important">S4</span> (matrix,matrix,ANY)</span>
<span class="functioncall">`nmf`</span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="symbol">rank</span><span class="keyword">,</span> <span class="symbol">method</span><span class="keyword">,</span> <span class="symbol">seed</span><span class="keyword">,</span> <span class="argument">model</span> <span class="argument">=</span> <span class="functioncall"><a href='http://www.inside-r.org/r-doc/base/list'>list</a></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> <span class="symbol">...</span><span class="keyword">)</span>

<span class="comment"><span class="label label-important">S4</span> (formula,ANY,ANY)</span>
<span class="functioncall">`nmf`</span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="symbol">rank</span><span class="keyword">,</span> <span class="symbol">method</span><span class="keyword">,</span> <span class="symbol">...</span><span class="keyword">,</span> <span class="argument">model</span> <span class="argument">=</span> NULL<span class="keyword">)</span>

<span class="comment"><span class="label label-important">S4</span> (matrix,numeric,NMFStrategy)</span>
<span class="functioncall">`nmf`</span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="symbol">rank</span><span class="keyword">,</span> <span class="symbol">method</span><span class="keyword">,</span> <span class="argument">seed</span> <span class="argument">=</span> <span class="functioncall"><a href='options.html'>nmf.getOption</a></span><span class="keyword">(</span><span class="string">"default.seed"</span><span class="keyword">)</span><span class="keyword">,</span> <span class="argument">nrun</span> <span class="argument">=</span> <span class="keyword">if</span> <span class="keyword">(</span><span class="functioncall"><a href='http://www.inside-r.org/r-doc/base/length'>length</a></span><span class="keyword">(</span><span class="symbol">rank</span><span class="keyword">)</span> <span class="keyword">&gt;</span>
      <span class="number">1</span><span class="keyword">)</span> <span class="number">30</span> <span class="keyword">else</span> <span class="number">1</span><span class="keyword">,</span> <span class="argument">model</span> <span class="argument">=</span> NULL<span class="keyword">,</span> <span class="argument">.options</span> <span class="argument">=</span> <span class="functioncall"><a href='http://www.inside-r.org/r-doc/base/list'>list</a></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> <span class="argument">.pbackend</span> <span class="argument">=</span> <span class="functioncall"><a href='options.html'>nmf.getOption</a></span><span class="keyword">(</span><span class="string">"backend"</span><span class="keyword">)</span><span class="keyword">,</span>
      <span class="argument">.callback</span> <span class="argument">=</span> NULL<span class="keyword">,</span> <span class="symbol">...</span><span class="keyword">)</span></pre>
    
    <h2>Arguments</h2>
    <dl>
      <dt>x</dt>
      <dd>target data to fit, i.e. a matrix-like object</dd>
      <dt>rank</dt>
      <dd>specification of the factorization rank. It
  is usually a single numeric value, but other type of
  values are possible (e.g. matrix), for which specific
  methods are implemented. See for example methods
  <code>nmf,matrix,matrix,ANY</code>.

  If <code>rank</code> is a numeric vector with more than one
  element, e.g. a range of ranks, then <code><a href='nmf.html'>nmf</a></code>
  performs the estimation procedure described in
  <code><a href='nmfEstimateRank.html'>nmfEstimateRank</a></code>.</dd>
      <dt>method</dt>
      <dd>specification of the NMF algorithm. The
  most common way of specifying the algorithm is to pass
  the access key (i.e. a character string) of an algorithm
  stored in the package's dedicated registry, but methods
  exists that handle other types of values, such as
  <code>function</code> or <code>list</code> object. See their
  descriptions in section <em>Methods</em>.

  If <code>method</code> is missing the algorithm to use is
  obtained from the option
  <code>nmf.getOption('default.algorithm')</code>, unless it can
  be infer from the type of NMF model to fit, if this later
  is available from other arguments. Factory fresh default
  value is &#145;brunet&#146;, which corresponds to the
  standard NMF algorithm from <cite>Brunet2004</cite> (see
  section <em>Algorithms</em>).

  Cases where the algorithm is inferred from the call are
  when an NMF model is passed in arguments <code>rank</code> or
  <code>seed</code> (see description for
  <code>nmf,matrix,numeric,NULL</code> in section
  <em>Methods</em>).</dd>
      <dt>...</dt>
      <dd>extra arguments to allow extension of the
  generic. Arguments that are not used in the chain of
  internal calls to <code>nmf</code> methods are passed to the
  function that effectively implements the algorithm that
  fits an NMF model on <code>x</code>.</dd>
      <dt>name</dt>
      <dd>name associated with the NMF algorithm
  implemented by the function <code>method</code> [only used when
  <code>method</code> is a function].</dd>
      <dt>objective</dt>
      <dd>specification of the objective function
  associated with the algorithm implemented by the function
  <code>method</code> [only used when <code>method</code> is a
  function].

  It may be either <code>'euclidean'</code> or <code>'KL'</code> for
  specifying the euclidean distance (Frobenius norm) or the
  Kullback-Leibler divergence respectively, or a function
  with signature <code>(x="NMF", y="matrix", ...)</code> that
  computes the objective value for an NMF model <code>x</code> on
  a target matrix <code>y</code>, i.e. the residuals between the
  target matrix and its NMF estimate. Any extra argument
  may be specified, e.g. <code>function(x, y, alpha,
  beta=2, ...)</code>.</dd>
      <dt>mixed</dt>
      <dd>a logical that indicates if the algorithm
  implemented by the function <code>method</code> support
  mixed-sign target matrices, i.e. that may contain
  negative values [only used when <code>method</code> is a
  function].</dd>
      <dt>seed</dt>
      <dd>specification of the starting point or
  seeding method, which will compute a starting point,
  usually using data from the target matrix in order to
  provide a good guess.

  The seeding method may be specified in the following way:

  <span class='describe'>

  a <code>character</code> string: giving the name of a
  <em>registered</em> seeding method. The corresponding
  method will be called to compute the starting point.

  Available methods can be listed via <code>nmfSeed()</code>. See
  its dedicated documentation for details on each available
  registered methods (<code><a href='nmfSeed.html'>nmfSeed</a></code>). 

  a <code>list</code>: giving the name of a
  <em>registered</em> seeding method and, optionally, extra
  parameters to pass to it.

  a single <code>numeric</code>: that is used to seed the
  random number generator, before generating a random
  starting point.

  Note that when performing multiple runs, the L'Ecuyer's
  RNG is used in order to produce a sequence of random
  streams, that is used in way that ensures that parallel
  computation are fully reproducible. 

  an object that inherits from
  <code><a href='NMF-class.html'>NMF-class</a></code>: it should contain the data of
  an initialised NMF model, i.e. it must contain valid
  basis and mixture coefficient matrices, directly usable
  by the algorithm's workhorse function.

  a <code>function</code>: that computes the starting
  point. It must have signature <code>(object="NMF",
  target="matrix", ...)</code> and return an object that inherits
  from class <code>NMF</code>. It is recommended to use argument
  <code>object</code> as a template for the returned object, by
  only updating the basis and coefficient matrices, using
  <code><a href='basis-coef-methods.html'>basis<-</a></code> and <code><a href='basis-coef-methods.html'>coef<-</a></code>
  respectively. 

  </span></dd>
      <dt>model</dt>
      <dd>specification of the type of NMF model to
  use.

  It is used to instantiate the object that inherits from
  class <code><a href='NMF-class.html'>NMF-class</a></code>, that will be passed to
  the seeding method. The following values are supported:
  <ul>
<li> <code>NULL</code>, the default model associated to the
  NMF algorithm is instantiated and <code>...</code> is looked-up
  for arguments with names that correspond to slots in the
  model class, which are passed to the function
  <code><a href='nmfModel.html'>nmfModel</a></code> to instantiate the model.
  Arguments in <code>...</code> that do not correspond to slots
  are passed to the algorithm.

  </li>
<li> a single <code>character</code> string, that is the name
  of the NMF model class to be instantiate.  In this case,
  arguments in <code>...</code> are handled in the same way as
  when <code>model</code> is <code>NULL</code>.

  </li>
<li> a <code>list</code> that contains named values that are
  passed to the function <code><a href='nmfModel.html'>nmfModel</a></code> to
  instantiate the model.  In this case, <code>...</code> is not
  looked-up at all, and passed entirely to the algorithm.
  This means that all necessary model parameters must be
  specified in <code>model</code>.

  </li>
</ul>


  <strong>Argument/slot conflicts:</strong> In the case a parameter
  of the algorithm has the same name as a model slot, then
  <code>model</code> MUST be a list -- possibly empty --, if one
  wants this parameter to be effectively passed to the
  algorithm.

  If a variable appears in both arguments <code>model</code> and
  <code>...</code>, the former will be used to initialise the
  NMF model, the latter will be passed to the NMF
  algorithm.  See code examples for an illustration of this
  situation.</dd>
      <dt>nrun</dt>
      <dd>number of runs to perform. It specifies the
  number of runs to perform. By default only one run is
  performed, except if <code>rank</code> is a numeric vector with
  more than one element, in which case a default of 30 runs
  per value of the rank are performed, allowing the
  computation of a consensus matrix that is used in
  selecting the appropriate rank (see
  <code><a href='connectivity.html'>consensus</a></code>).

  When using a random seeding method, multiple runs are
  generally required to achieve stability and avoid
  <em>bad</em> local minima.</dd>
      <dt>.options</dt>
      <dd>this argument is used to set runtime
  options.

  It can be a <code>list</code> containing named options with
  their values, or, in the case only boolean/integer
  options need to be set, a character string that specifies
  which options are turned on/off or their value, in a
  unix-like command line argument way.

  The string must be composed of characters that correspond
  to a given option (see mapping below), and modifiers '+'
  and '-' that toggle options on and off respectively. E.g.
  <code>.options='tv'</code> will toggle on options <code>track</code>
  and <code>verbose</code>, while <code>.options='t-v'</code> will
  toggle on option <code>track</code> and toggle off option
  <code>verbose</code>.

  Modifiers '+' and '-' apply to all option character found
  after them: <code>t-vp+k</code> means <code>track=TRUE</code>,
  <code>verbose=parallel=FALSE</code>, and <code>keep.all=TRUE</code>.
  The default behaviour is to assume that <code>.options</code>
  starts with a '+'.

  for options that accept integer values, the value may be
  appended to the option's character e.g. <code>'p4'</code> for
  asking for 4 processors or <code>'v3'</code> for showing
  verbosity message up to level 3.

  The following options are available (the characters after
  &#147;-&#148; are those to use to encode <code>.options</code> as
  a string): <span class='describe'>

  debug - d Toggle debug mode (default:
  <code>FALSE</code>). Like option <code>verbose</code> but with more
  information displayed.

  keep.all - k used when performing multiple runs
  (<code>nrun</code>>1): if <code>TRUE</code>, all factorizations are
  saved and returned (default: <code>FALSE</code>). Otherwise
  only the factorization achieving the minimum residuals is
  returned.

  parallel - p this option is useful on multicore
  *nix or Mac machine only, when performing multiple runs
  (<code>nrun</code> > 1) (default: <code>TRUE</code>). If <code>TRUE</code>,
  the runs are performed using the parallel foreach backend
  defined in argument <code>.pbackend</code>. If this is set to
  <code>'mc'</code> or <code>'par'</code> then <code>nmf</code> tries to
  perform the runs using multiple cores with package
  <code>link[doParallel]{doParallel}</code> -- which therefore
  needs to be installed.

  If equal to an integer, then <code>nmf</code> tries to perform
  the computation on the specified number of processors.
  When passing options as a string the number is appended
  to the option's character e.g. <code>'p4'</code> for asking for
  4 processors.

  If <code>FALSE</code>, then the computation is performed
  sequentially using the base function
  <code><a href='http://www.inside-r.org/r-doc/BiocGenerics/lapply'>sapply</a></code>.

  Unlike option 'P' (capital 'P'), if the computation
  cannot be performed in parallel, then it will still be
  carried on sequentially.

  <strong>IMPORTANT NOTE FOR MAC OS X USERS:</strong> The parallel
  computation is based on the <code>doMC</code> and
  <code>multicore</code> packages, so the same care should be
  taken as stated in the vignette of <code>doMC</code>:
  <em>&#147;it is not safe to use doMC from R.app on
  Mac OS X. Instead, you should use doMC from a terminal
  session, starting R from the command line.&#148;</em> 

  parallel.required - P Same as <code>p</code>, but an
  error is thrown if the computation cannot be performed in
  parallel or with the specified number of processors.

  restore.seed - r deprecated option since version
  0.5.99. Will throw a warning if used.

  simplifyCB - S toggle simplification of the
  callback results. Default is <code>TRUE</code>

  track - t enables error tracking (default:
  FALSE). If <code>TRUE</code>, the returned object's slot
  <code>residuals</code> contains the trajectory of the objective
  values, which can be retrieved via <code>residuals(res,
  track=TRUE)</code> This tracking functionality is available for
  all built-in algorithms. 

  verbose - v Toggle verbosity (default:
  <code>FALSE</code>). If <code>TRUE</code>, messages about the
  configuration and the state of the current run(s) are
  displayed. The level of verbosity may be specified with
  an integer value, the greater the level the more messages
  are displayed. Value <code>FALSE</code> means no messages are
  displayed, while value <code>TRUE</code> is equivalent to
  verbosity level 1. 

  </span></dd>
      <dt>.pbackend</dt>
      <dd>specification of the
  <code><a href='http://www.inside-r.org/r-doc/foreach/foreach'>foreach</a></code> parallel backend to register and/or
  use when running in parallel mode. See options <code>p</code>
  and <code>P</code> in argument <code>.options</code> for how to
  enable this mode. Note that any backend that is
  internally registered is cleaned-up on exit, so that the
  calling foreach environment should not be affected by a
  call to <code>nmf</code> -- except when <code>.pbackend=NULL</code>.

  Currently it accepts the following values: <span class='describe'>

  &#145;par&#146; use the backend(s) defined by the
  package <code><a href='http://www.inside-r.org/r-doc/doParallel/doParallel-package'>doParallel</a></code>; a numeric
  value use the specified number of cores with
  <code>doParallel</code> backend; &#145;seq&#146; use the
  foreach sequential backend <code>doSEQ</code>;
  <code>NULL</code> use currently registered backend;
  <code>NA</code> do not compute using a foreach loop --
  and therefore not in parallel -- but rather use a call to
  standard <code><a href='http://www.inside-r.org/r-doc/BiocGenerics/lapply'>sapply</a></code>. This is useful for when
  developing/debugging NMF algorithms, as foreach loop
  handling may sometime get in the way.

  Note that this is equivalent to using
  <code>.options='-p'</code> or <code>.options='p0'</code>, but takes
  precedence over any option specified in <code>.options</code>:
  e.g. <code>nmf(..., .options='P10', .pbackend=NA)</code>
  performs all runs sequentially using <code>sapply</code>. Use
  <code>nmf.options(backend=NA)</code> to completely disable
  foreach/parallel computations for all subsequent
  <code>nmf</code> calls.

  &#145;mc&#146; identical to &#145;par&#146; and defined
  to ensure backward compatibility. </span></dd>
      <dt>.callback</dt>
      <dd>Used when option <code>keep.all=FALSE</code>
  (default).  It allows to pass a callback function that is
  called after each run when performing multiple runs (i.e.
  with <code>nrun>1</code>). This is useful for example if one is
  also interested in saving summary measures or process the
  result of each NMF fit before it gets discarded. After
  each run, the callback function is called with two
  arguments, the <code><a href='NMFfit-class.html'>NMFfit-class</a></code> object that as
  just been fitted and the run number: <code>.callback(res,
  i)</code>. For convenience, a function that takes only one
  argument or has signature <code>(x, ...)</code> can still be
  passed in <code>.callback</code>. It is wrapped internally into
  a dummy function with two arguments, only the first of
  which is passed to the actual callback function (see
  example with <code>summary</code>).

  The call is wrapped into a tryCatch so that callback
  errors do not stop the whole computation (see below).

  The results of the different calls to the callback
  function are stored in a miscellaneous slot accessible
  using the method <code>$</code> for <code>NMFfit</code> objects:
  <code>res$.callback</code>. By default <code>nmf</code> tries to
  simplify the list of callback result using <code>sapply</code>,
  unless option <code>'simplifyCB'</code> is <code>FASE</code>.

  If no error occurs <code>res$.callback</code> contains the list
  of values that resulted from the calling the callback
  function --, ordered as the fits. If any error occurs in
  one of the callback calls, then the whole computation is
  <strong>not</strong> stopped, but the error message is stored in
  <code>res$.callback</code>, in place of the result.

  See the examples for sample code.</dd>
    </dl>
    
    <div class="Value">
      <h2>Value</h2>
      
      <p>The returned value depends on the run mode:</p>
  
      <p>Single run:An object of class
  <code><a href='NMFfit-class.html'>NMFfit-class</a></code>.</p>
  
      <p>Multiple runs, single method:When <code>nrun > 1</code>
  and <code>method</code> is not <code>list</code>, this method returns
  an object of class <code><a href='NMFfitX-class.html'>NMFfitX-class</a></code>.</p>
  
      <p>Multiple runs, multiple methods:When <code>nrun >
  1</code> and <code>method</code> is a <code>list</code>, this method
  returns an object of class <code><a href='NMFList-class.html'>NMFList-class</a></code>.</p>
  
    </div>

    <div class="Description">
      <h2>Description</h2>
      
      <p>The function <code>nmf</code> is a S4 generic defines the main
  interface to run NMF algorithms within the framework
  defined in package <code>NMF</code>. It has many methods that
  facilitates applying, developing and testing NMF
  algorithms.</p>
  
      <p>The package vignette <code>vignette('NMF')</code> contains an
  introduction to the interface, through a sample data
  analysis.</p>
  
    </div>

    <div class="Details">
      <h2>Details</h2>
      
      <p>The <code>nmf</code> function has multiple methods that compose
  a very flexible interface allowing to: <ul>
<li>
  combine NMF algorithms with seeding methods and/or
  stopping/convergence criterion at runtime;</p>
  
      <p></li>
<li> perform multiple NMF runs, which are computed in
  parallel whenever the host machine allows it;</p>
  
      <p></li>
<li> run multiple algorithms with a common set of
  parameters, ensuring a consistent environment (notably
  the RNG settings). </li>
</ul></p>
  
      <p>The workhorse method is
  <code>nmf,matrix,numeric,NMFStrategy</code>, which is
  eventually called by all other methods. The other methods
  provides convenient ways of specifying the NMF
  algorithm(s), the factorization rank, or the seed to be
  used. Some allow to directly run NMF algorithms on
  different types of objects, such as <code>data.frame</code> or
  <code><a href='http://www.inside-r.org/r-doc/Biobase/class.ExpressionSet'>ExpressionSet</a></code> objects.</p>
  
    </div>

    <div class="Methods">
      <h2>Methods</h2>
      
      <p><span class='describe'></p>
  
      <p>nmf<code>signature(x = "data.frame", rank =
  "ANY", method = "ANY")</code>: Fits an NMF model on a
  <code>data.frame</code>.</p>
  
      <p>The target <code>data.frame</code> is coerced into a matrix
  with <code><a href='http://www.inside-r.org/r-doc/base/matrix'>as.matrix</a></code>.</p>
  
      <p>nmf<code>signature(x = "matrix", rank =
  "numeric", method = "NULL")</code>: Fits an NMF model using an
  appropriate algorithm when <code>method</code> is not supplied.</p>
  
      <p>This method tries to select an appropriate algorithm
  amongst the NMF algorithms stored in the internal
  algorithm registry, which contains the type of NMF models
  each algorithm can fit. This is possible when the type of
  NMF model to fit is available from argument <code>seed</code>,
  i.e. if it is an NMF model itself. Otherwise the
  algorithm to use is obtained from
  <code>nmf.getOption('default.algorithm')</code>.</p>
  
      <p>This method is provided for internal usage, when called
  from other <code>nmf</code> methods with argument <code>method</code>
  missing in the top call (e.g.
  <code>nmf,matrix,numeric,missing</code>).</p>
  
      <p>nmf<code>signature(x = "matrix", rank =
  "numeric", method = "list")</code>: Fits multiple NMF models on
  a common matrix using a list of algorithms.</p>
  
      <p>The models are fitted sequentially with <code>nmf</code> using
  the same options and parameters for all algorithms. In
  particular, irrespective of the way the computation is
  seeded, this method ensures that all fits are performed
  using the same initial RNG settings.</p>
  
      <p>This method returns an object of class
  <code><a href='NMFList-class.html'>NMFList-class</a></code>, that is essentially a list
  containing each fit.</p>
  
      <p>nmf<code>signature(x = "matrix", rank =
  "numeric", method = "character")</code>: Fits an NMF model on
  <code>x</code> using an algorithm registered with access key
  <code>method</code>.</p>
  
      <p>Argument <code>method</code> is partially match against the
  access keys of all registered algorithms (case
  insensitive). Available algorithms are listed in section
  <em>Algorithms</em> below or the introduction vignette. A
  vector of their names may be retrieved via
  <code>nmfAlgorithm()</code>.</p>
  
      <p>nmf<code>signature(x = "matrix", rank =
  "numeric", method = "function")</code>: Fits an NMF model on
  <code>x</code> using a custom algorithm defined the function
  <code>method</code>.</p>
  
      <p>The supplied function must have signature
  <code>(x=matrix, start=NMF, ...)</code> and return an object
  that inherits from class <code><a href='NMF-class.html'>NMF-class</a></code>. It
  will be called internally by the workhorse <code>nmf</code>
  method, with an NMF model to be used as a starting point
  passed in its argument <code>start</code>.</p>
  
      <p>Extra arguments in <code>...</code> are passed to <code>method</code>
  from the top <code>nmf</code> call. Extra arguments that have
  no default value in the definition of the function
  <code>method</code> are required to run the algorithm (e.g. see
  argument <code>alpha</code> of <code>myfun</code> in the examples).</p>
  
      <p>If the algorithm requires a specific type of NMF model,
  this can be specified in argument <code>model</code> that is
  handled as in the workhorse <code>nmf</code> method (see
  description for this argument).</p>
  
      <p>nmf<code>signature(x = "matrix", rank = "NMF",
  method = "ANY")</code>: Fits an NMF model using the NMF model
  <code>rank</code> to seed the computation, i.e. as a starting
  point.</p>
  
      <p>This method is provided for convenience as a shortcut for
  <code>nmf(x, nbasis(object), method, seed=object, ...)</code>
  It discards any value passed in argument <code>seed</code> and
  uses the NMF model passed in <code>rank</code> instead. It
  throws a warning if argument <code>seed</code> not missing.</p>
  
      <p>If <code>method</code> is missing, this method will call the
  method <code>nmf,matrix,numeric,NULL</code>, which will infer
  an algorithm suitable for fitting an NMF model of the
  class of <code>rank</code>.</p>
  
      <p>nmf<code>signature(x = "matrix", rank = "NULL",
  method = "ANY")</code>: Fits an NMF model using the NMF model
  supplied in <code>seed</code>, to seed the computation, i.e. as
  a starting point.</p>
  
      <p>This method is provided for completeness and is
  equivalent to <code>nmf(x, seed, method, ...)</code>.</p>
  
      <p>nmf<code>signature(x = "matrix", rank =
  "missing", method = "ANY")</code>: Method defined to ensure the
  correct dispatch to workhorse methods in case of argument
  <code>rank</code> is missing.</p>
  
      <p>nmf<code>signature(x = "matrix", rank =
  "numeric", method = "missing")</code>: Method defined to ensure
  the correct dispatch to workhorse methods in case of
  argument <code>method</code> is missing.</p>
  
      <p>nmf<code>signature(x = "matrix", rank = "matrix",
  method = "ANY")</code>: Fits an NMF model partially seeding the
  computation with a given matrix passed in <code>rank</code>.</p>
  
      <p>The matrix <code>rank</code> is used either as initial value
  for the basis or mixture coefficient matrix, depending on
  its dimension.</p>
  
      <p>Currently, such partial NMF model is directly used as a
  seed, meaning that the remaining part is left
  uninitialised, which is not accepted by all NMF
  algorithm. This should change in the future, where the
  missing part of the model will be drawn from some random
  distribution.</p>
  
      <p>Amongst built-in algorithms, only &#145;snmf/l&#146; and
  &#145;snmf/r&#146; support partial seeds, with only the
  coefficient or basis matrix initialised respectively.</p>
  
      <p>nmf<code>signature(x = "matrix", rank =
  "data.frame", method = "ANY")</code>: Shortcut for <code>nmf(x,
  as.matrix(rank), method, ...)</code>.</p>
  
      <p>nmf<code>signature(x = "formula", rank = "ANY",
  method = "ANY")</code>: This method implements the interface
  for fitting formula-based NMF models. See
  <code><a href='nmfModel.html'>nmfModel</a></code>.</p>
  
      <p>Argument <code>rank</code> target matrix or formula
  environment. If not missing, <code>model</code> must be a
  <code>list</code>, a <code>data.frame</code> or an <code>environment</code>
  in which formula variables are searched for.</p>
  
      <p></span></p>
  
    </div>

    <div class="Optimized C++ vs. plain R">
      <h2>Optimized C++ vs. plain R</h2>
      
      <p>Lee and Seung's multiplicative updates are used by
  several NMF algorithms. To improve speed and memory
  usage, a C++ implementation of the specific matrix
  products is used whenever possible. It directly computes
  the updates for each entry in the updated matrix, instead
  of using multiple standard matrix multiplication.</p>
  
      <p>The algorithms that benefit from this optimization are:
  'brunet', 'lee', 'nsNMF' and 'offset'. 
  However there still exists plain R versions for these
  methods, which implement the updates as standard matrix
  products. These are accessible by adding the prefix '.R#'
  to their name: '.R#brunet', '.R#lee', '.R#nsNMF' and
  '.R#offset'.</p>
  
    </div>

    <div class="Algorithms">
      <h2>Algorithms</h2>
      
      <p>All algorithms are accessible by their respective access
  key as listed below. The following algorithms are
  available: <span class='describe'></p>
  
      <p>&#145;brunet&#146; Standard NMF, based on the
  Kullback-Leibler divergence, from <cite>Brunet et al. (2004)</cite>. It
  uses simple multiplicative updates from <cite>Lee et al. (2001)</cite>,
  enhanced to avoid numerical underflow.</p>
  
      <p>Default stopping criterion: invariance of the
  connectivity matrix (see
  <code><a href='stop-NMF.html'>nmf.stop.connectivity</a></code>).</p>
  
      <p>&#145;lee&#146; Standard NMF based on the Euclidean
  distance from <cite>Lee et al. (2001)</cite>. It uses simple
  multiplicative updates.</p>
  
      <p>Default stopping criterion: invariance of the
  connectivity matrix (see
  <code><a href='stop-NMF.html'>nmf.stop.connectivity</a></code>).</p>
  
      <p>ls-nmf Least-Square NMF from <cite>Wang et al. (2006)</cite>. It
  uses modified versions of Lee and Seung's multiplicative
  updates for the Euclidean distance, which incorporates
  weights on each entry of the target matrix, e.g. to
  reflect measurement uncertainty.</p>
  
      <p>Default stopping criterion: stationarity of the objective
  function (see <code><a href='stop-NMF.html'>nmf.stop.stationary</a></code>).</p>
  
      <p>&#145;nsNMF&#146; Nonsmooth NMF from
  <cite>Pascual-Montano et al. (2006)</cite>. It uses a modified version of
  Lee and Seung's multiplicative updates for the
  Kullback-Leibler divergence <cite>Lee et al. (2001)</cite>, to fit a
  extension of the standard NMF model, that includes an
  intermediate smoothing matrix, meant meant to produce
  sparser factors.</p>
  
      <p>Default stopping criterion: invariance of the
  connectivity matrix (see
  <code><a href='stop-NMF.html'>nmf.stop.connectivity</a></code>).</p>
  
      <p>&#145;offset&#146; NMF with offset from
  <cite>Badea (2008)</cite>. It uses a modified version of Lee and
  Seung's multiplicative updates for Euclidean distance
  <cite>Lee et al. (2001)</cite>, to fit an NMF model that includes an
  intercept, meant to capture a common baseline and shared
  patterns, in order to produce cleaner basis components.</p>
  
      <p>Default stopping criterion: invariance of the
  connectivity matrix (see
  <code><a href='stop-NMF.html'>nmf.stop.connectivity</a></code>).</p>
  
      <p>&#145;pe-nmf&#146; Pattern-Expression NMF from
  <em>Zhang2008</em>. It uses multiplicative updates to
  minimize an objective function based on the Euclidean
  distance, that is regularized for effective expression of
  patterns with basis vectors.</p>
  
      <p>Default stopping criterion: stationarity of the objective
  function (see <code><a href='stop-NMF.html'>nmf.stop.stationary</a></code>).</p>
  
      <p>&#145;snmf/r&#146;, &#145;snmf/l&#146; Alternating
  Least Square (ALS) approach from <cite>Kim et al. (2007)</cite>. It
  applies the nonnegative least-squares algorithm from
  <cite>Van Benthem et al. (2004)</cite> (i.e. fast combinatorial
  nonnegative least-squares for multiple right-hand), to
  estimate the basis and coefficient matrices alternatively
  (see <code><a href='fcnnls.html'>fcnnls</a></code>). It minimises an
  Euclidean-based objective function, that is regularized
  to favour sparse basis matrices (for &#145;snmf/l&#146;) or
  sparse coefficient matrices (for &#145;snmf/r&#146;).</p>
  
      <p>Stopping criterion: built-in within the workhorse
  function <code>.nmfsh_comb</code>, based on the KKT optimality
  conditions.</p>
  
      <p></span></p>
  
    </div>

    <div class="Seeding methods">
      <h2>Seeding methods</h2>
      
      <p>The purpose of seeding methods is to compute initial
  values for the factor matrices in a given NMF model. This
  initial guess will be used as a starting point by the
  chosen NMF algorithm.</p>
  
      <p>The seeding method to use in combination with the
  algorithm can be passed to interface <code>nmf</code> through
  argument <code>seed</code>. The seeding seeding methods
  available in registry are listed by the function
  <code><a href='nmfSeed.html'>nmfSeed</a></code> (see list therein).</p>
  
      <p>Detailed examples of how to specify the seeding method
  and its parameters can be found in the <em>Examples</em>
  section of this man page and in the package's vignette.</p>
  
    </div>

    <div class="References">
      <h2>References</h2>
      
      <p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
  "Metagenes and molecular pattern discovery using matrix
  factorization." _Proceedings of the National Academy of
  Sciences of the United States of America_, *101*(12), pp.
  4164-9. ISSN 0027-8424, <URL:
  http://dx.doi.org/10.1073/pnas.0308531101>, <URL:
  http://www.ncbi.nlm.nih.gov/pubmed/15016911>.</p>
  
      <p>Lee DD and Seung H (2001). "Algorithms for non-negative
  matrix factorization." _Advances in neural information
  processing systems_. <URL:
  http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization\#0>.</p>
  
      <p>Wang G, Kossenkov AV and Ochs MF (2006). "LS-NMF: a
  modified non-negative matrix factorization algorithm
  utilizing uncertainty estimates." _BMC bioinformatics_,
  *7*, pp. 175. ISSN 1471-2105, <URL:
  http://dx.doi.org/10.1186/1471-2105-7-175>, <URL:
  http://www.ncbi.nlm.nih.gov/pubmed/16569230>.</p>
  
      <p>Pascual-Montano A, Carazo JM, Kochi K, Lehmann D and
  Pascual-marqui RD (2006). "Nonsmooth nonnegative matrix
  factorization (nsNMF)." _IEEE Trans. Pattern Anal. Mach.
  Intell_, *28*, pp. 403-415.</p>
  
      <p>Badea L (2008). "Extracting gene expression profiles
  common to colon and pancreatic adenocarcinoma using
  simultaneous nonnegative matrix factorization." _Pacific
  Symposium on Biocomputing. Pacific Symposium on
  Biocomputing_, *290*, pp. 267-78. ISSN 1793-5091, <URL:
  http://www.ncbi.nlm.nih.gov/pubmed/18229692>.</p>
  
      <p>Kim H and Park H (2007). "Sparse non-negative matrix
  factorizations via alternating non-negativity-constrained
  least squares for microarray data analysis."
  _Bioinformatics (Oxford, England)_, *23*(12), pp.
  1495-502. ISSN 1460-2059, <URL:
  http://dx.doi.org/10.1093/bioinformatics/btm134>, <URL:
  http://www.ncbi.nlm.nih.gov/pubmed/17483501>.</p>
  
      <p>Van Benthem M and Keenan MR (2004). "Fast algorithm for
  the solution of large-scale non-negativity-constrained
  least squares problems." _Journal of Chemometrics_,
  *18*(10), pp. 441-450. ISSN 0886-9383, <URL:
  http://dx.doi.org/10.1002/cem.889>, <URL:
  http://doi.wiley.com/10.1002/cem.889>.</p>
  
    </div>
    
    <h2 id="examples">Examples</h2>
    <pre class="examples"><div class='input'><span class="comment"># Only basic calls are presented in this manpage.</span>
<span class="comment"># Many more examples are provided in the demo file nmf.R</span>
<span class="comment">## &lt;strong&gt;Not run&lt;/strong&gt;: </span>
<span class="comment"># demo('nmf')</span>
<span class="comment"># ## &lt;strong&gt;End(Not run)&lt;/strong&gt;</span>

<span class="comment"># random data</span>
<span class="symbol">x</span> <span class="assignement">&lt;-</span> <span class="functioncall"><a href='rmatrix.html'>rmatrix</a></span><span class="keyword">(</span><span class="number">20</span><span class="keyword">,</span><span class="number">10</span><span class="keyword">)</span>

<span class="comment"># run default algorithm with rank 2</span>
<span class="symbol">res</span> <span class="assignement">&lt;-</span> <span class="functioncall"><a href='nmf.html'>nmf</a></span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="number">2</span><span class="keyword">)</span>

<span class="comment"># specify the algorithm</span>
<span class="symbol">res</span> <span class="assignement">&lt;-</span> <span class="functioncall"><a href='nmf.html'>nmf</a></span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="number">2</span><span class="keyword">,</span> <span class="string">'lee'</span><span class="keyword">)</span>

<span class="comment"># get verbose message on what is going on</span>
<span class="symbol">res</span> <span class="assignement">&lt;-</span> <span class="functioncall"><a href='nmf.html'>nmf</a></span><span class="keyword">(</span><span class="symbol">x</span><span class="keyword">,</span> <span class="number">2</span><span class="keyword">,</span> <span class="argument">.options</span><span class="argument">=</span><span class="string">'v'</span><span class="keyword">)</span></div>
<strong class='message'>NMF algorithm: 'brunet'</strong>
<strong class='message'>NMF seeding method: random</strong>
<div class='output'>Iterations: 1 50 100 150 200 250 300 350 400 450 500 550 600 650 700 750 800
DONE (stopped at 840/2000 iterations)
</div>
<div class='input'>## <strong>Not run</strong>: 
# # more messages
# res <- nmf(x, 2, .options='v2')
# # even more
# res <- nmf(x, 2, .options='v3')
# # and so on ...
# ## <strong>End(Not run)</strong>
</div></pre>
  </div>
  <div class="span4">
    <!-- <ul>
      <li>nmf</li><li>nmf,data.frame,ANY,ANY-method</li><li>nmf,formula,ANY,ANY-method</li><li>nmf,matrix,data.frame,ANY-method</li><li>nmf,matrix,matrix,ANY-method</li><li>nmf,matrix,missing,ANY-method</li><li>nmf,matrix,NMF,ANY-method</li><li>nmf,matrix,NULL,ANY-method</li><li>nmf,matrix,numeric,character-method</li><li>nmf,matrix,numeric,function-method</li><li>nmf,matrix,numeric,list-method</li><li>nmf,matrix,numeric,missing-method</li><li>nmf,matrix,numeric,NMFStrategy-method</li><li>nmf,matrix,numeric,NULL-method</li><li>nmf-methods</li>
    </ul>
    <ul>
      <li>methods</li>
    </ul> -->
      
    <h2>See also</h2>
    
  <code><a href='nmfAlgorithm.html'>nmfAlgorithm</a></code>

        
  </div>
</div>
      
      <footer>
      <p class="pull-right"><a href="#">Back to top</a></p>
<p>Built by <a href="https://github.com/hadley/staticdocs">staticdocs</a>. Styled with <a href="http://twitter.github.com/bootstrap">bootstrap</a>.</p>
      </footer>
    </div>
  </body>
</html>